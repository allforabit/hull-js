// Generated by CoffeeScript 1.3.3
(function() {

  define(function() {
    return function(env) {
      var core, rpc;
      core = env.core;
      rpc = false;
      return {
        config: {
          require: {
            paths: {
              easyXDM: 'easyXDM/easyXDM'
            },
            shim: {
              easyXDM: {
                exports: 'easyXDM'
              }
            }
          }
        },
        init: function() {
          var Backbone, Collection, Model, api, batch, easyXDM, exec, extractApiArgs, initialized, message, methodMap, models, onRemoteMessage, slice, sync, _;
          _ = require('underscore');
          Backbone = require('backbone');
          easyXDM = require('easyXDM');
          slice = Array.prototype.slice;
          extractApiArgs = function(args) {
            var callback, errback, method, next, params, path, ret, type;
            callback = errback = null;
            path = args.shift();
            next = args.shift();
            if (typeof path !== 'string') {
              throw new Error("Invalid path passed to Hull.api()");
            }
            while (next) {
              type = typeof next;
              if (type === 'string' && !method) {
                method = next.toLowerCase();
              } else if (type === 'function' && (!callback || !errback)) {
                if (!callback) {
                  callback = next;
                } else if (!errback) {
                  errback = next;
                }
              } else if (type === 'object' && !params) {
                params = next;
              } else {
                throw new Error("Invalid argument passed to Hull.api(): " + next);
              }
              next = args.shift();
            }
            if (method == null) {
              method = 'get';
            }
            if (params == null) {
              params = {};
            }
            if (callback == null) {
              callback = function() {};
            }
            if (errback == null) {
              errback = function(err, data) {
                return console.error('Uncaught error: ', err, data);
              };
            }
            ret = [
              {
                path: path,
                method: method,
                params: params
              }, callback, errback
            ];
            return ret;
          };
          message = function(params, callback, errback) {
            var onError, onSuccess, promise;
            if (!rpc) {
              console.error("Api not initialized yet");
            }
            promise = core.data.deferred();
            onSuccess = function(res) {
              callback(res);
              return promise.resolve(res);
            };
            onError = function(err) {
              errback(err);
              return promise.reject(err);
            };
            rpc.message(params, onSuccess, onError);
            return promise;
          };
          exec = function(m) {
            var method;
            method = m;
            return function(serviceName) {
              var args, req;
              args = extractApiArgs(slice.call(arguments, 1));
              req = args[0];
              if (req.path[0] === "/") {
                req.path = req.path.substring(1);
              }
              req.path = [serviceName, req.path].join("/");
              req.method = method;
              return message.apply(api, args);
            };
          };
          batch = function() {
            var args, callback, errback, next, promises, requests, res, responses, type;
            args = slice.call(arguments);
            promises = [];
            requests = [];
            responses = [];
            callback = errback = null;
            while (next) {
              type = typeof next;
              if (type === 'function') {
                if (!callback) {
                  callback = next;
                } else if (!errback) {
                  errback = next;
                } else {
                  throw new Error('Incorrect arguments passed to Hull.batch(). Only callback & errback can be defined.');
                }
              } else {
                requests.push(next);
              }
              next = args.shift();
            }
            _.map(requests, function(request) {
              var req;
              if (_.isString(request)) {
                req = [
                  {
                    path: request,
                    method: 'get'
                  }
                ];
              } else {
                req = [request];
              }
              return promises.push(message.apply(api, req));
            });
            res = core.data.when.apply($, promises);
            res.then(callback, errback);
            return res;
          };
          api = function() {
            return message.apply(api, extractApiArgs(slice.call(arguments)));
          };
          methodMap = {
            'create': 'post',
            'update': 'put',
            'delete': 'delete',
            'read': 'get'
          };
          sync = function(method, model, options) {
            var dfd, url;
            if (options == null) {
              options = {};
            }
            url = _.isFunction(model.url) ? model.url() : model.url;
            dfd = api(url, methodMap[method], model.toJSON());
            dfd.then(options.success);
            dfd.fail(options.error);
            return dfd;
          };
          models = {};
          api.model = function(attrs) {
            var dfd, model;
            if (_.isString(attrs)) {
              attrs = {
                _id: attrs
              };
            }
            if ((attrs != null ? attrs._id : void 0) == null) {
              throw new Error('A model must have an identifier...');
            }
            model = models[attrs._id];
            if (model == null) {
              model = models[attrs._id] = new Model();
              model._id = attrs._id;
              model._fetched = false;
              dfd = model.deferred = core.data.deferred();
              model.on('change', function() {
                var args, eventName, _ref;
                args = slice.call(arguments);
                eventName = "hull.model." + model._id + '.' + 'change';
                return core.pubsub.emit(eventName, {
                  eventName: eventName,
                  model: model,
                  changes: (_ref = args[1]) != null ? _ref.changes : void 0
                });
              });
              model.fetch({
                success: function() {
                  model._fetched = true;
                  return dfd.resolve(model);
                },
                error: function() {
                  return dfd.fail(model);
                }
              });
            }
            return model;
          };
          api.model.clearAll = function() {
            return models = {};
          };
          Model = Backbone.Model.extend({
            sync: sync,
            url: function() {
              return "hull/" + this._id;
            }
          });
          Collection = Backbone.Collection.extend({
            url: function() {
              return "hull/" + this._id;
            },
            sync: sync
          });
          api.collection = function(ext) {
            return Collection.extend(ext);
          };
          api.get = exec('get');
          api.post = exec('post');
          api.put = exec('put');
          api.del = exec('delete');
          api.batch = batch;
          core.data.api = api;
          initialized = core.data.deferred();
          onRemoteMessage = function() {
            return console.warn("RPC Message", arguments);
          };
          rpc = new easyXDM.Rpc({
            remote: "" + env.config.orgUrl + "/api/v1/" + env.config.appId + "/remote.html"
          }, {
            remote: {
              message: {},
              ready: {}
            },
            local: {
              message: onRemoteMessage,
              ready: function() {
                return initialized.resolve();
              }
            }
          });
          return initialized;
        }
      };
    };
  });

}).call(this);
